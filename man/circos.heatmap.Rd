\name{circos.heatmap}
\alias{circos.heatmap}
\title{
Make circular heatmaps
}
\description{
Make circular heatmaps
}
\usage{
circos.heatmap(x, split = NULL, col, na.col = "grey",
    ignore_white = TRUE, default.par = TRUE,
    cluster = TRUE, clustering.method = "complete", distance.method = "euclidean",
    dend.side = c("none", "outside", "inside"), dend.track.height = 0.1,
    rownames.side = c("none", "outside", "inside"),
    rownames.cex = 0.5,
    rownames.font = par("font"),
    ...)
}
\arguments{

  \item{x}{A matrix or a list of matrices. If the value is a vector, it is converted into a one-column matrix.}
  \item{split}{A categorical variable. If the \code{x} is a matrix, it splits the matrix into a list of matrices.}
  \item{col}{If the values in the matrices are continuous, the color should be a color mapping generated by  \code{\link{colorRamp2}}. If the values are characters, the color should be a named color vector.}
  \item{na.col}{Color for \code{NA} values.}
  \item{ignore_white}{Whether to draw the white color?}
  \item{default.par}{By default \code{\link{circos.par}} is set as \code{cell.padding = c(0, 0, 0, 0), track.margin = c(0.02, 0), gap.degree = 2}. Set this value to \code{FALSE} to use your own \code{\link{circos.par}}.}
  \item{cluster}{whether to apply clustering on rows.}
  \item{clustering.method}{Clustering method, pass to \code{\link[stats]{hclust}}.}
  \item{distance.method}{Distance method, pass to \code{\link[stats]{dist}}.}
  \item{dend.side}{Side of the dendrograms relative to the heatmap track.}
  \item{dend.track.height}{Track height of the dendrograms.}
  \item{rownames.side}{Side of the row names relative to the heatmap track.}
  \item{rownames.cex}{Cex of row names.}
  \item{rownames.font}{Font of row names.}
  \item{...}{Pass to \code{\link{circos.track}} which draws the heatmap track.}

}
\examples{
set.seed(123)
mat = matrix(rnorm(1000), nr = 100)
rownames(mat) = paste0("R", 1:100)
split = rep(letters[1:5], times = 10)

circos.clear()
circos.heatmap(mat, split = split,
    col = colorRamp2(c(-2, 0, 2), c("blue", "white", "red")))

row_mean = rowMeans(mat)
circos.track(ylim = range(row_mean), panel.fun = function(x, y) {
    y = row_mean[split == CELL_META$sector.index]
    y = y[CELL_META$row_order]
    circos.lines(CELL_META$cell.xlim, c(0, 0), lty = 2, col = "grey")
    circos.points(seq_along(y) - 0.5, y, col = ifelse(y > 0, "red", "blue"))
}, cell.padding = c(0.02, 0, 0.02, 0))
circos.clear()

circos.clear()
circos.heatmap.initialize(mat, split = split)
row_mean = rowMeans(mat)
circos.track(ylim = range(row_mean), panel.fun = function(x, y) {
    y = row_mean[split == CELL_META$sector.index]
    y = y[CELL_META$row_order]
    circos.lines(CELL_META$cell.xlim, c(0, 0), lty = 2, col = "grey")
    circos.points(seq_along(y) - 0.5, y, col = ifelse(y > 0, "red", "blue"))
}, cell.padding = c(0.02, 0, 0.02, 0))
circos.heatmap(mat, col = colorRamp2(c(-2, 0, 2), c("blue", "white", "red")))
circos.clear()
}
